-----
Разбор инъекции зависимостей (внедрение зависимостей).
ASP.NET Core использует упрощенное создание контейнера для внедрения зависимостей.
Например у нас есть три страницы (Page1, Page2, Page3) и функциональность - Email и DB.
Также у нас будет новый объект DI CONTAINER, это контейнер для внедрения зависимостей (ioc container), 
теперь вместо экземпляров класса для каждой страницы, у нас также будут интерфейсы для Email и DB и классы 
будут реализовывать эти интерфейсы. Мы зарегистрируем интерфейсы в нашем контейнере. Те мы сообщим DI контейнеру, 
что интерфейс IEmail и этот класс Email, то реализация этого интерфейса, для подключения функционала электр почты.
Каждая страница просто вызовет DI CONTAINER для создания объекта этой функциональности, страница может использовать этот объект. 
Внутри страницы фактически будут использованы только интерфейсы.  
Какие преимущества? Нам не придется возиться с созданием объекта, удалением его или управлением этим объектом в коде наших страниц.
-----
Startup
Есть два метода. ConfigureServices и Configure, они вызываются автоматически в ASP.NET Core. 
В ConfigureServices будут регистрироваться все зависимости в DI контейнере, который уже встроен в ASP.NET Core в ConfigureServices. 
Шаг, который мы делаем при регистрации интерфейсов и сервисом, таких как управление эл почтой или бд, это шаг, 
который мы сделаем внутри ConfigureServices.
Сервисы, это любой функционал, который мы хотим зарегистрировать, чтобы другие части приложения, могли его использовать (эл почта, бд…).
В Configure в проверке мы проверяем, в каком режиме запускается приложение. Параметр iWebHost… настраивает конвейер (разберем) для прохождения http запросов в ASP.NET Core.
Конвейер определяет как приложение будет отвечать на http запрос.
-----
PIPELINE (конвейер)
У нас есть разные браузеры и pipeline. Когда приложение получает запрос от браузера (request from browser), запрос обратно возвращается 
через pipeline и обычно обрабатывается всякими middleware, типа проверки авторизации, сессий, для доступа к стат файлам итд. 
Наш запрос проходит через эти компоненты.
-----
Маршрутизация в MVC.
Я не буду это расписывать (одно и тоже что и в express в nodejs), типа http://localhost:5000/{controller}/{action}/{id}. На ноде там :id.
-----
appsettings.json
Файл в котором мы будем добавлять строки подключения и другие файлы, которые мы хотим скрыть. 
Сейчас уже есть настройка для логов.
-----
Папка wwwRoot и файл launchSettings.json.
Папка wwwRoot была создана, потому я выбрал приложение MVC. В ней есть стат файлы.
Файл launchSettings.json Это различные профили с которых мы можем запускать приложение, типа build dev test итд
-----
MVC
У нас осталось три папки Controllers Models и Views. Это и есть MVC
-----
Архитектура MVC приложений.
MODEL – форма данных, классы в C# используют для описания модели, 
 компоненты модели связаны с логикой данных с которыми мы работает 
 пользователь (корзина, юзер, таблицы в бд итд). Все св-ва в классе будут столбцами таблицы в бд. 
VIEW – пользовательский интерфейс (UI), все что мы видим, фронт короче. 
 Логика пользовательского интерфейса.
CONTROLLER – обрабатывает запрос пользователя, например отправка формы, post/get запрос. Генерируется http запрос (req). 
 Далее контроллер использует модель а также view. А потом возвращает ответ (res).  
-----
Контроллер явл сердцем нашего приложения. Внутри него много action методов. 
Если имя нашего контроллера Home, то внутри Views у нас обязательно должна быть папка с именем 
Home и уже туда мы добавляем все представления, которые связаны с action методами (Index.cshtml или Privacy.cshtml).
-----
Ход моей разработки:
1.	Добавление строки подключения к БД в файле appsettings.json.
2.	Установка контекста в БД в файле ApplicationDbContext.cs. Перед этим скачаем entity framework. Далее создадим конструктор (сниппет ctor), мы передаем некие параметры DbContextOptions, настроим класс ApplicationDbContext назовем параметр options, мы передаем все эти параметры в базовый класс DbContext и этот объект будет содержать строку подключения.
3.	Создадим таблицу Category в БД. Каждый раз если мы хотим создать подобное, мы должны обращаться к ApplicationDbContext. Создадим св-во DbSet, внутри класса сущность Category с именем Category.
4.	Настроим DbContext в файле Startup.cs для использования нашим приложением при его запуске. Для этого добавим сервис для создания контекста бд. Используем метод AddDbContext, вставляем ссылку на имя объекта и настраиваем параметры (мы их передаем в DbContext).
5.	Нам нужно добавить миграцию, чтобы отправить это в бд. Для этого в консоли NuGet напишем add-migration addCategoryToDatabase. Entity автоматически преобразовал модель в миграцию. Далее отправим эту миграцию. update-database. И так, если нам нужно сделать изменение, мы сначала вносим его добавляя миграцию, а затем обновляем обновляем бд вставляя миграцию в бд.
6.	Далее добавим новый контроллер CategoryController.cs, изменим верстку в_Layout.cshtml и добавим представление для метода Index в контроллере Category.
7.	На странице Category (Index), нам нужно отобразить все категории, которые сущ в бд. Для этого в CategoryController получим значение используя инъекцию зависимости. Создадим св-во и ссылку для этого св-ва с помощью конструктора используя внедрение зависимости. Тк в стартапе мы добавили dbcontext, если нужно извлечь что-нибудь из этого контейнера, то в конструкторе мы ссылаемся на класс или имя интерфейса. _db = db.
8.	Получим объект со всеми категориями с нашей бд: IEnumerable<Category> objList = _db.Category;  Entity все сделает.
9.	Всегда, когда мы передаем что либо из контроллера, нам всегда нужно проверить, что мы приняли ссылку внутри представления: @model IEnumerable<RR_hookah.Models.Category>. 
10.	Верстка
11.	Сейчас создадим страницу с функционалом создания новой категории. Для этого добавим новый action метод Create, далее создадим представления. В нем вставим ссылку на модель, она нужна для ввода новых значений. Добавим форму с методом пост и несколько хелпер тегов: asp-action="Create" когда форма выполняет пост метод, то выполняется поиск action метода типа пост с именем Create. 
12.	Создадим ссылку в View Index. Чтобы перейти на другую стр, нужно перейти к action методу, те Create. Используем asp-action=”Create”, внутри контроллера Category контроллер asp-controller=”Category”.
13.	Добавим текстовые поля, для добавления новых параметров категории (имя, порядок отображения). Верстка. Преимущество тег хелпера asp-for в том, что нам становится доступна аннотация данных.
14.	 У нас есть кнопка и форма типа submit/post. Теперь нам надо добавить метод пост для контроллера Create. Далее добавляем в бд. Сохраняем изменения. Делаем редирект.

Итог как добавить модель в бд:
	1.	Добавление модели в Models
	2.	Добавление в бд в Data в ApplicationDbContext
	3.	Добавление миграции (в консоли)
	4.	Обновление бд (в консоли)
Итог как создать контроллер Application Type
	1.	Добавление контроллера для get и post запросов в Controllers
	2.	Добавление представления 

15.	Валидация, я не буду это расписывать. 
16.	Добавление кнопки редактировать и удаления категории. Для этого добавим два якорных тега поменяем название action тегов для них. Самое главное с помощью тега asp-route-Id=”obj.Id” определяем id каждой категории.
17.	Метод get для редактирования категории. Для этого добавим контроллер Edit, также мы передаем id параметром, тк он передается через тег хелпер asp-route-Id. И далее просто получаем категорию на основе id из бд. Добавим преставление.
18.	Обновление категории. Для этого добавим метод пост в контроллере. Однако сейчас мы столкнемся с ошибкой, потому что в представлении Edit, здесь мы используем name и DisplayOrder, однако id у нас нигде нет ! Чтобы это исправить, добавим скрытый инпут в представлении, это частая практика, я так делал, когда использовал hbs с express.
19.	Удаление категории. Если название action метода не совпадает с названием представления, нам достаточно указать название action метода в теге хелп в представлении: asp-action="DeletePost"
20. Теперь нам нужно добавить сущность товара. Создадим класс модели. Создадим все необходимые св-ва. Также нам нужно настроить внешний ключ с идентификатором сущности category. Для этого создадим публичное виртуальное св-во типа Category, назовем Category и добавим сеттеры и геттеры. В этом случае Entity framework автоматически создает связь между Product и Category. Также мы явно можем добавить объект сопоставления CategoryId. Также создадим связь через ForeignKey.
21.   ВАЖНО!!! Перед миграцией нам нужно изменить в файле  ApplicationDbContext, я не понял почему ☹, что-то с null и required.
22. Теперь нам нужно добавить модель в бд. В ApplicationDbContext добавим public DbSet<Product> Product { get; set; }. Далее создадим новую миграцию. Обновим бд.
23. Создадим CRUD операции для product. Первое что сделаем, создадим контроллер product. Начнем с action метода Index. В модели продукт также есть объект категория. И поэтому в случае когда нужно вывести на экран информацию о продукт, нужно будет также выводить название категории. Нужно загрузить объект category используя цикл foreach. Obj.Category это результат извлечения из бд с помощью метода FirstOrDefault, и нам нужна первая сущность, которая соответствует условию: u.Id == obj.CategoryId. Те из всех имеющихся сущностей Products будет извлечена и присвоена модель Category на основе условия. 

24.	Перед тем как добавлять товары в список, создадим представление. Нужно сделать создание и обновление товара совместить в одном представлении. В Product можно совместить ради примера, в одном action методе. И так в кнопках нам не нужно указывать имя контроллера, тк они будут находиться в одном контроллере. Далее указываем комбинированное название Upsert. Он отвечает за создание и обновление Product. 
25.	Работаем над action методом типа гет. Как отличить входящий запрос для создания товара от запроса на ред. Товара ? если нужно ред, то будет входящий Id, типа инт. Иначе null. Далее нам нужен объект типа продукт (это инстанс класса в js).  Далее в зависимости от id выполняем код. Также нам нужно получить продукт из бд и передать этот объект во вью.
26. Создадим представление для Upsert. Сначала создадим редактирование. Для изображений добавим enctype="multipart/form-data". Нужно помнить что мы используем одну страницу для двух действий и к нам не всегда приходит айди. Для этого добавим проверку if и также динамически будем изменять title. Далее просто работаем над версткой. 
27.	Добавление раскрывающегося списка всех категорий. Сначала нам нужно получить этот список внутри контроллера в методе upsert типа get и передать в представление. Для этого мы можем использовать viewdata или viewbag, если необходимо передать некоторые данные из контроллеров в представление. И так, добавим еще одно св-во IEnumerable<SelectListItem>, назовем его CategoryDropDown и здесь извлечем все категории из бд. Для этого обратимся к _db к Category, а затем используем метод Select, и в лямбда выражении запишем, что I такое что явл новым SelectListItem с св-вами Text = i.Name и Value = i.Id.toString(). Далее просто передаем наш объект во View, используя viewBag, как назовем и что хоти назначить. Изи ебат.
28. Разбор что мы использовали. ViewBag. Он передает данные из контроллера в представление, но не наоборот. Он идеально подходит для ситуаций, в котором временные данные не содержатся в модели. Время жизни длится в пределах текущего http запроса. Значение теряется после любого перенаправления кода. Он явл оболочкой вокруг viewData. 
Что такое  viewData ? Также передает данные. Имеет тип данных Dictionary (ключ значение). Нужно делать приведение типа. Важно!!! При этом внутри viewbag данные хранятся в словаре viewdata, но ключ для viewdata и св-во viewbag это две РАЗНЫЕ вещи.
Позже рассмотрим tempData. 
Однако мы не будем использовать эти штуки для выпадающего списка.
29. Правильно использовать строгую типизацию представлений. Сейчас наше представление знает какой тип модели ожидается о контроллера. Но используя три штуки выше, наше представление теряет строгую типизацию.  Лучше всего использовать viewModel.
30. Viewmodel – содержит поля, которые нужны для представлений. Это модель определённого view, или сразу для нескольких представлений. Они могут иметь логику для валидации, используя аннотацию данных для проверки моделей. ViewModel помогает реализовать строгую типизацию представления !  Может быть нескольких сущностей в нескольких моделей.
31. Создадим viewModel для action метода Upsert. Для начала добавим папку и файл ProductVM. Создадим св-во, которое использовалось в контроллере product. Теперь мы можем создать новый объект ProductVM в контроллере (инстанс класса). Здесь мы загружаем ViewModel типа ProductVM, с добавлением пустого объекта Product и объектом CategorySelectList, Далее если id не равен null, то извлекаем Product из бд для нашей viewModel. 
32. Изменение представления Upsert. Теперь там ProductVM и не нужен ViewData.
33. Валидация изображения. Воспользуемся библиотекой SweetAlert. 
34. Добавим продвинутый редактор текста summernote.
35. Поработаем над созданием товара. Будем хранить изображения в wwwroot. И так далее создадим файл, который будет содержать все константы нашего веб приложения. Создадим константу пути до папки изображений. Теперь нам нужна корневая папка нашего приложения, чтобы получить к ней доступ, применим паттерн зависимости встроенный private readonly IWebHostEnvironment _webHostEnvironment;. Создадим переменную изображения files. Далее путь до файла wwwroot. Далее если id = 0, то нам необходим код для создания новой сущности, иначе редактирования. Далее пишем код на C# для копирования файла в новое место, которое определяется значением upload. Далее обновляем ссылку на images. Добавляем товар и не забываем обновить изменения !!!
36. Добавим вывод изображения при редактировании.
37. Редактирование товара. Сначала проверим, если фото новое, то нам нужно удалить старое фото и заменить новым. И так, сначала получим товар на основе айди из бд в переменную objFromDb. …
38. Entity создает трекинг сущности продукт. Он фиксирует объект из вью модели, а также отслеживает объект типа продукт, к которому мы обратились objFromDb. Одновременно Entity не может отслеживать одни и те же объекты, при обновлении не ясно, какую   сущность следует обновлять. Нужно обновить productVM.Product или _db.Product.FirstOrDefault. У них у обоих одинаковые ключи. Решение, нужно обновить только одно. Для этого нужно установить AsNoTracking.
39. Удаление товара. Используем жадную загрузку (eager), это способ сообщить Entity что когда мы загружаем продукт, нужно модифицировать операцию join в бд и также загрузить соответствующую категорию, если она будет найдена.
40. Создание view для удаления.
41.	Теперь нужно создать страницу подробнее о товаре. На ней мы покажем всю детальную информацию о товаре. А также сделаем возможность добавлять в корзину. Однако нельзя добавить больше 1 товара. Недостаточно использовать только сущность продукт. Тк нужно использовать св-во в котором хранится инфа о есть товар в корзине или нет. Для этого создадим DetailsVM. 
42. В ней добавим отдельную сущность Product, далее ExistsInCart типа int и создадим конструктор и в нем создадим новый экземпляр класса Product (теперь нам не нужно создавать такой объект внутри контроллера, который будет использовать ту вью модель).
43. Создание action метода Details, куда мы передаем id. Получим продукт из бд на основе id.  Зададим продукт , u такое что у него есть Category, полсе нам нужен сам объект продукт на основе id, значит где u такое что u.id = полученному id, далее заберем именно первую запись. 
44. Представление Details

СЕССИИ / ИДЕНТИФИКАЦИЯ
45. Для того, чтобы настроить кнопку добавить в корзину, нужно использовать сессии. В ConfigureServices добавим             services.AddHttpContextAccessor();
            services.AddSession(Options =>
            {
                Options.IdleTimeout = TimeSpan.FromMinutes(10);
                Options.Cookie.HttpOnly = true;
                Options.Cookie.IsEssential = true;
            });
Теперь             // middleware для обработки сессий
            app.UseSession();
46. По умолчанию код для обработки сессий может хранить только целые числа или строки. Для этого создадим служебную папку, куда можно добавить все доп сервисы (SessionExtensions). Добавим метод Set для сериализации, те:
Serialize - Преобразует значение указанного типа в строку JSON.
session.SetString - Задает строковое значение в ISession .

В Get выполним десириализацю. Мы создали методы расширения для сессий, чтобы можно было сохранять сложные объекты путем их сериализации и де сериализации.
47. Теперь нам нужен ключ для доступа к сеансу. Для этого у нас есть класс веб констант. Добавим SessionCart. В файле лейаут добавим проверку на включение сессий… Однако для этого в нашей сессии должен быть список всех id товаров. Для этого создадим специальную модель (тк дальше придется добавлять новые много св-св) ShoppingCart, куда добавим id. Теперь в лейаут добавим список моделей ShoppingCart.
48. Чтобы получить доступ к сессии внутри представления, нужно подключить HttpContextAccessor, Microsoft.AspNetCore.Http и папка Utility. Далее в if HttpContextAccessor.HttpContext.Session.Get<List<ShoppingCart>>(WC.SessionCart) != null
Это наш метод Get. 
49. Теперь нам нужно добавлять предметы в сессию. Только ProductId. Для этого добавим action метод в HomeController. В нем сначала создадим список для корзины покупок. Далее проверка на сущ сессии. Если она сущ, то мы берем объект сессии и добавляем туда элемент. Иначе добавим новый товар в корзину и далее устанавливаем сессию.
50. Удаление из корзины. В методе get Details значение ExistsInCart нужно устанавливать по другому, нам нужно извлечь сессию и проверить указан ли этот товар в сессии или нет, и уже тогда менять значение. Сделаем это. После того как у нас появляется доступ к объекту shoppingCartList, можно извлечь все эл этого списка и проверить находится ли уже выбранный товар в списке.  
51. action метод для удаления. Создадим RemoveFromCart с передачей id. Нужно проверить, был ли он добавлен ранее. Комментарии в коде.
52. Добавим библиотеку для идентификации с нуля. Начнем с DBContext. Необходимо наследовать ApplicationDbContext от IdentityDbContext. Настроим файл startup.cs. Однако сначала установим identity ui. Теперь в ConfigureServices и в Configure добавим строки подключения. Добавим миграцию и обновление бд.
53. Теперь когда в бд созданы таблицы для системы  Identity, нужно использовать страницы для входа, регистрации итд. Aspnetcore предоставляет такую возможность по умолчанию. Для этого перейдем на уровень проекта, нажмем правую кнопку мыши и добавим Identity. В нем выберем все, укажем путь до _Layout и снизу выберем ApplicationDbContext. Теперь когда у нас есть Razor страницы, нам нужно сообщить о них dotnetcore. Для этого добавим новый маршрут для razor в Startup.cs. 
54. В папке Manage есть множество страниц, но это не MVC. Они содержат файлы с расширением .cs, но там не обычный код, это специальный тип кода для страниц Razor. В файле Register у нас есть !обработчики! get и post запросов. И так в get у нас будет функциональность, описывающая действие при загрузки страницы, а в post будет функциональность обработки нажатия кнопки отправки. Как добавить страницу в нашу главную страницу _Layout. Для этого
пропишем в нем <partial name="_LoginPartial"/> обычно перед тегом ul.
55.  Модификация таблиц системы Идентификации.  Сейчас я хочу добавить имя пользователя при регистрации в форме. Для этого нужно добавить новый класс ApplicationUser в папку Modals. Добавим наследование. И теперь при добавлении новых св-св в этот класс, будет изменяться наша таблица по умолчанию. Далее нужно сделать миграцию AddFullNameToUsersTable и обновим бд.
56. Определим роли для пользователя (админ, клиент итд). Сейчас у нас будет две роли. Для этого в веб константах добавим две стат переменные для ролей AdminRole и ClientRole. Теперь создадим эти роли. Для этого в папке Account, есть файл Register и модель. Настроим модель. В этом файле есть InputModel с [BindProperty], это привязка к представлению Razer. Теперь добавим в InputModel  и добавим туда новые св-ва. Однако PhoneNumber уже есть в бд, нам нужно его извлечь, для этого добавим их в верстке. При создании нового пользователя (метод пост), проверим заполнены ли поля. И вместо экземпляра IdentityUser создадим ApplicationUser, далее добавим эти св-ва.
57. Настройка ролей. Первый зарег пользователь будет админом. Работаем внутри класса Register. Подключим _roleManager и добавим в конструктор и значение параметра. Сначала создадим эти роли. В методе гет. Изменим стартап, те укажем что мы хотим роли. 
58. Регистрация пользователя. Перейдем в пост метод. Зададим права нашему пользователю.
59. По умолчанию пользователь не должен получать права админа. Исправим это. Добавим код для управления правами на странице регистрации
60. Все готово кроме корзины, но ее я создавать не буду 😊
61. Локализация - https://www.youtube.com/watch?v=Hy9G30nncMM


MODELS:
1.	Модель категории:
    1.	Id
    2.	Name
    3.	DisplayOrder

2.	Модель товара:
    1.	Id
    2.	Name
    3.	Description
    4.	Price
    5.	Image (string)

3.	ShoppingCart
    1.	ProductId

4.	Модель юзера, однако она уже готова в решении от Entity Framework


