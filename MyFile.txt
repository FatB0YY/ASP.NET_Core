-----
Разбор инъекции зависимостей (внедрение зависимостей).
ASP.NET Core использует упрощенное создание контейнера для внедрения зависимостей.
Например у нас есть три страницы (Page1, Page2, Page3) и функциональность - Email и DB.
Также у нас будет новый объект DI CONTAINER, это контейнер для внедрения зависимостей (ioc container), 
теперь вместо экземпляров класса для каждой страницы, у нас также будут интерфейсы для Email и DB и классы 
будут реализовывать эти интерфейсы. Мы зарегистрируем интерфейсы в нашем контейнере. Те мы сообщим DI контейнеру, 
что интерфейс IEmail и этот класс Email, то реализация этого интерфейса, для подключения функционала электр почты.
Каждая страница просто вызовет DI CONTAINER для создания объекта этой функциональности, страница может использовать этот объект. 
Внутри страницы фактически будут использованы только интерфейсы.  
Какие преимущества? Нам не придется возиться с созданием объекта, удалением его или управлением этим объектом в коде наших страниц.
-----
Startup
Есть два метода. ConfigureServices и Configure, они вызываются автоматически в ASP.NET Core. 
В ConfigureServices будут регистрироваться все зависимости в DI контейнере, который уже встроен в ASP.NET Core в ConfigureServices. 
Шаг, который мы делаем при регистрации интерфейсов и сервисом, таких как управление эл почтой или бд, это шаг, 
который мы сделаем внутри ConfigureServices.
Сервисы, это любой функционал, который мы хотим зарегистрировать, чтобы другие части приложения, могли его использовать (эл почта, бд…).
В Configure в проверке мы проверяем, в каком режиме запускается приложение. Параметр iWebHost… настраивает конвейер (разберем) для прохождения http запросов в ASP.NET Core.
Конвейер определяет как приложение будет отвечать на http запрос.
-----
PIPELINE (конвейер)
У нас есть разные браузеры и pipeline. Когда приложение получает запрос от браузера (request from browser), запрос обратно возвращается 
через pipeline и обычно обрабатывается всякими middleware, типа проверки авторизации, сессий, для доступа к стат файлам итд. 
Наш запрос проходит через эти компоненты.
-----
Маршрутизация в MVC.
Я не буду это расписывать (одно и тоже что и в express в nodejs), типа http://localhost:5000/{controller}/{action}/{id}. На ноде там :id.
-----
appsettings.json
Файл в котором мы будем добавлять строки подключения и другие файлы, которые мы хотим скрыть. 
Сейчас уже есть настройка для логов.
-----
Папка wwwRoot и файл launchSettings.json.
Папка wwwRoot была создана, потому я выбрал приложение MVC. В ней есть стат файлы.
Файл launchSettings.json Это различные профили с которых мы можем запускать приложение, типа build dev test итд
-----
MVC
У нас осталось три папки Controllers Models и Views. Это и есть MVC
-----
Архитектура MVC приложений.
MODEL – форма данных, классы в C# используют для описания модели, 
 компоненты модели связаны с логикой данных с которыми мы работает 
 пользователь (корзина, юзер, таблицы в бд итд). Все св-ва в классе будут столбцами таблицы в бд. 
VIEW – пользовательский интерфейс (UI), все что мы видим, фронт короче. 
 Логика пользовательского интерфейса.
CONTROLLER – обрабатывает запрос пользователя, например отправка формы, post/get запрос. Генерируется http запрос (req). 
 Далее контроллер использует модель а также view. А потом возвращает ответ (res).  
-----
Контроллер явл сердцем нашего приложения. Внутри него много action методов. 
Если имя нашего контроллера Home, то внутри Views у нас обязательно должна быть папка с именем 
Home и уже туда мы добавляем все представления, которые связаны с action методами (Index.cshtml или Privacy.cshtml).
-----
Ход моей разработки:
1.	Добавление строки подключения к БД в файле appsettings.json.
2.	Установка контекста в БД в файле ApplicationDbContext.cs. Перед этим скачаем entity framework. Далее создадим конструктор (сниппет ctor), мы передаем некие параметры DbContextOptions, настроим класс ApplicationDbContext назовем параметр options, мы передаем все эти параметры в базовый класс DbContext и этот объект будет содержать строку подключения.
3.	Создадим таблицу Category в БД. Каждый раз если мы хотим создать подобное, мы должны обращаться к ApplicationDbContext. Создадим св-во DbSet, внутри класса сущность Category с именем Category.
4.	Настроим DbContext в файле Startup.cs для использования нашим приложением при его запуске. Для этого добавим сервис для создания контекста бд. Используем метод AddDbContext, вставляем ссылку на имя объекта и настраиваем параметры (мы их передаем в DbContext).
5.	Нам нужно добавить миграцию, чтобы отправить это в бд. Для этого в консоли NuGet напишем add-migration addCategoryToDatabase. Entity автоматически преобразовал модель в миграцию. Далее отправим эту миграцию. update-database. И так, если нам нужно сделать изменение, мы сначала вносим его добавляя миграцию, а затем обновляем обновляем бд вставляя миграцию в бд.
6.	Далее добавим новый контроллер CategoryController.cs, изменим верстку в_Layout.cshtml и добавим представление для метода Index в контроллере Category.
7.	На странице Category (Index), нам нужно отобразить все категории, которые сущ в бд. Для этого в CategoryController получим значение используя инъекцию зависимости. Создадим св-во и ссылку для этого св-ва с помощью конструктора используя внедрение зависимости. Тк в стартапе мы добавили dbcontext, если нужно извлечь что-нибудь из этого контейнера, то в конструкторе мы ссылаемся на класс или имя интерфейса. _db = db.
8.	Получим объект со всеми категориями с нашей бд: IEnumerable<Category> objList = _db.Category;  Entity все сделает.
9.	Всегда, когда мы передаем что либо из контроллера, нам всегда нужно проверить, что мы приняли ссылку внутри представления: @model IEnumerable<RR_hookah.Models.Category>. 
10.	Верстка
11.	Сейчас создадим страницу с функционалом создания новой категории. Для этого добавим новый action метод Create, далее создадим представления. В нем вставим ссылку на модель, она нужна для ввода новых значений. Добавим форму с методом пост и несколько хелпер тегов: asp-action="Create" когда форма выполняет пост метод, то выполняется поиск action метода типа пост с именем Create. 
12.	Создадим ссылку в View Index. Чтобы перейти на другую стр, нужно перейти к action методу, те Create. Используем asp-action=”Create”, внутри контроллера Category контроллер asp-controller=”Category”.
13.	Добавим текстовые поля, для добавления новых параметров категории (имя, порядок отображения). Верстка. Преимущество тег хелпера asp-for в том, что нам становится доступна аннотация данных.
14.	 У нас есть кнопка и форма типа submit/post. Теперь нам надо добавить метод пост для контроллера Create. Далее добавляем в бд. Сохраняем изменения. Делаем редирект.

Итог как добавить модель в бд:
	1.	Добавление модели в Models
	2.	Добавление в бд в Data в ApplicationDbContext
	3.	Добавление миграции (в консоли)
	4.	Обновление бд (в консоли)
Итог как создать контроллер Application Type
	1.	Добавление контроллера для get и post запросов в Controllers
	2.	Добавление представления 

15.	Валидация, я не буду это расписывать. 
16.	Добавление кнопки редактировать и удаления категории. Для этого добавим два якорных тега поменяем название action тегов для них. Самое главное с помощью тега asp-route-Id=”obj.Id” определяем id каждой категории.
17.	Метод get для редактирования категории. Для этого добавим контроллер Edit, также мы передаем id параметром, тк он передается через тег хелпер asp-route-Id. И далее просто получаем категорию на основе id из бд. Добавим преставление.
18.	Обновление категории. Для этого добавим метод пост в контроллере. Однако сейчас мы столкнемся с ошибкой, потому что в представлении Edit, здесь мы используем name и DisplayOrder, однако id у нас нигде нет ! Чтобы это исправить, добавим скрытый инпут в представлении, это частая практика, я так делал, когда использовал hbs с express.
19.	Удаление категории. Если название action метода не совпадает с названием представления, нам достаточно указать название action метода в теге хелп в представлении: asp-action="DeletePost"
20.	
